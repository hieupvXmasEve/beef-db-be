// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, slug, description, image_url)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateCategoryParams struct {
	Name        string
	Slug        string
	Description pgtype.Text
	ImageUrl    pgtype.Text
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ImageUrl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    category_id,
    name,
    slug,
    description,
    price,
    price_sale,
    image_url,
    thumb_url
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreateProductParams struct {
	CategoryID  int32
	Name        string
	Slug        string
	Description string
	Price       float64
	PriceSale   float64
	ImageUrl    string
	ThumbUrl    string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Price,
		arg.PriceSale,
		arg.ImageUrl,
		arg.ThumbUrl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password)
VALUES ($1, $2)
RETURNING id
`

type CreateUserParams struct {
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Password)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, slug, description, image_url, created_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategory(ctx context.Context, id int32) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, description, image_url, created_at
FROM categories
WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT
    p.id,
    p.category_id,
    p.name,
    p.slug,
    p.description,
    p.price,
    p.price_sale,
    p.image_url,
    p.thumb_url,
    p.created_at,
    c.name as category_name,
    c.slug as category_slug
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE p.id = $1
`

type GetProductRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	Description  string
	Price        float64
	PriceSale    float64
	ImageUrl     string
	ThumbUrl     string
	CreatedAt    pgtype.Timestamp
	CategoryName string
	CategorySlug string
}

func (q *Queries) GetProduct(ctx context.Context, id int32) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.PriceSale,
		&i.ImageUrl,
		&i.ThumbUrl,
		&i.CreatedAt,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT
    p.id,
    p.category_id,
    p.name,
    p.slug,
    p.description,
    p.price,
    p.price_sale,
    p.image_url,
    p.thumb_url,
    p.created_at,
    c.name as category_name,
    c.slug as category_slug
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE p.slug = $1
`

type GetProductBySlugRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	Description  string
	Price        float64
	PriceSale    float64
	ImageUrl     string
	ThumbUrl     string
	CreatedAt    pgtype.Timestamp
	CategoryName string
	CategorySlug string
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.PriceSale,
		&i.ImageUrl,
		&i.ThumbUrl,
		&i.CreatedAt,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getTotalProducts = `-- name: GetTotalProducts :one
SELECT COUNT(*) AS total_count FROM products
`

func (q *Queries) GetTotalProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalProducts)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getTotalProductsByCategory = `-- name: GetTotalProductsByCategory :one
SELECT COUNT(*) AS total_count 
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE (SQLC_OMIT_IF_NULL($1::int4) IS NULL OR c.id = $1)
  AND (SQLC_OMIT_IF_NULL($2::text) IS NULL OR c.slug = $2)
`

type GetTotalProductsByCategoryParams struct {
	ID   int32
	Slug string
}

func (q *Queries) GetTotalProductsByCategory(ctx context.Context, arg GetTotalProductsByCategoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalProductsByCategory, arg.ID, arg.Slug)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, password, role, created_at, updated_at
FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, role, created_at, updated_at
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserCount = `-- name: GetUserCount :one
SELECT COUNT(*)
FROM users
`

func (q *Queries) GetUserCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getUserCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, description, image_url, created_at
FROM categories
ORDER BY created_at DESC
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
    p.id,
    p.category_id,
    p.name,
    p.slug,
    p.description,
    p.price,
    p.price_sale,
    p.image_url,
    p.thumb_url,
    p.created_at,
    c.name as category_name,
    c.slug as category_slug
FROM products p
JOIN categories c ON p.category_id = c.id
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32
	Offset int32
}

type ListProductsRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	Description  string
	Price        float64
	PriceSale    float64
	ImageUrl     string
	ThumbUrl     string
	CreatedAt    pgtype.Timestamp
	CategoryName string
	CategorySlug string
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.PriceSale,
			&i.ImageUrl,
			&i.ThumbUrl,
			&i.CreatedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
WITH total AS (
    SELECT COUNT(*) as count
    FROM products p
    JOIN categories c ON p.category_id = c.id
    WHERE c.id = $1 OR c.slug = $2
)
SELECT
    p.id,
    p.category_id,
    p.name,
    p.slug,
    p.description,
    p.price,
    p.price_sale,
    p.image_url,
    p.thumb_url,
    p.created_at,
    c.name as category_name,
    c.slug as category_slug,
    total.count as total_count
FROM products p
JOIN categories c ON p.category_id = c.id
CROSS JOIN total
WHERE c.id = $1 OR c.slug = $2
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type ListProductsByCategoryParams struct {
	ID     int32
	Slug   string
	Limit  int32
	Offset int32
}

type ListProductsByCategoryRow struct {
	ID           int32
	CategoryID   int32
	Name         string
	Slug         string
	Description  string
	Price        float64
	PriceSale    float64
	ImageUrl     string
	ThumbUrl     string
	CreatedAt    pgtype.Timestamp
	CategoryName string
	CategorySlug string
	TotalCount   int64
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]ListProductsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory,
		arg.ID,
		arg.Slug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsByCategoryRow
	for rows.Next() {
		var i ListProductsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.PriceSale,
			&i.ImageUrl,
			&i.ThumbUrl,
			&i.CreatedAt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, role, created_at, updated_at
FROM users
`

type ListUsersRow struct {
	ID        int64
	Email     string
	Role      string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories
SET name = $1, slug = $2, description = $3, image_url = $4
WHERE id = $5
`

type UpdateCategoryParams struct {
	Name        string
	Slug        string
	Description pgtype.Text
	ImageUrl    pgtype.Text
	ID          int32
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.Exec(ctx, updateCategory,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ImageUrl,
		arg.ID,
	)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
    category_id = $1,
    name = $2,
    slug = $3,
    description = $4,
    price = $5,
    price_sale = $6,
    image_url = $7,
    thumb_url = $8
WHERE id = $9
`

type UpdateProductParams struct {
	CategoryID  int32
	Name        string
	Slug        string
	Description string
	Price       float64
	PriceSale   float64
	ImageUrl    string
	ThumbUrl    string
	ID          int32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Price,
		arg.PriceSale,
		arg.ImageUrl,
		arg.ThumbUrl,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET email = $1
WHERE id = $2
`

type UpdateUserParams struct {
	Email string
	ID    int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.Email, arg.ID)
	return err
}
